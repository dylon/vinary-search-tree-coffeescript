// Generated by CoffeeScript 1.7.1
(function() {
  var Entity, MaxHeap, Node, RangeIterator, Tree, f, global, p,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof exports !== 'undefined') {
    global = exports;
    Entity = require('./entity').vst.Entity;
    Node = require('./node').vst.Node;
    RangeIterator = require('./range_iterator').vst.RangeIterator;
    MaxHeap = require('./max_heap').vst.MaxHeap;
    p = require('./predicates').vst.predicates;
    f = require('./functions').vst.functions;
  } else if (typeof window !== 'undefined') {
    global = window;
    Entity = window.vst.Entity;
    Node = window.vst.Node;
    RangeIterator = window.vst.RangeIterator;
    MaxHeap = window.vst.MaxHeap;
    p = window.vst.predicates;
    f = window.vst.functions;
  } else {
    global = this;
    Entity = this.vst.Entity;
    Node = this.vst.Node;
    RangeIterator = this.vst.RangeIterator;
    MaxHeap = this.vst.MaxHeap;
    p = this.vst.predicates;
    f = this.vst.functions;
  }

  Tree = (function(_super) {
    __extends(Tree, _super);

    function Tree(subtypes) {
      if (subtypes == null) {
        subtypes = [];
      }
      if (this.constructor === Tree) {
        throw new Error("vst.Tree should not be instantiated directly");
      }
      if (subtypes.length === 0) {
        throw new Error("You must specify the subtype as an array to this constructor");
      }
      subtypes.push(Tree);
      Tree.__super__.constructor.call(this, subtypes);
    }

    Tree.prototype.is_node_type = function(node) {
      return node instanceof this.NodeType();
    };

    Tree.prototype.assert_is_node_type = function(node) {
      return f.assert(this.is_node_type(node), "Expected " + (f.to_string(node)) + " to be a " + (this.NodeType().name));
    };

    Tree.prototype.height = function() {
      if (p.is_defined(this.root())) {
        return this.root().height();
      } else {
        return 0;
      }
    };

    Tree.prototype.greatest = function(node) {
      if (node == null) {
        node = this.root();
      }
      if (node === null) {
        return null;
      }
      this.assert_is_node_type(node);
      while (node.greater_child()) {
        node = node.greater_child();
      }
      return node;
    };

    Tree.prototype.least = function(node) {
      if (node == null) {
        node = this.root();
      }
      if (node === null) {
        return null;
      }
      this.assert_is_node_type(node);
      while (node.lesser_child()) {
        node = node.lesser_child();
      }
      return node;
    };

    Tree.prototype.try_insert = function(key, value) {
      f.assert(p.is_defined(key));
      f.assert(p.is_defined(value));
      if (p.is_null(this.root())) {
        this.root(this.NodeType().of(key, value));
        this.size(this.size() + 1);
        return true;
      } else if (this.contains_key(key) === false) {
        this.add_descendant(this.root(), this.NodeType().of(key, value));
        this.size(this.size() + 1);
        return true;
      } else {
        return false;
      }
    };

    Tree.prototype.insert = function(key, value) {
      var node;
      f.assert(p.is_defined(key));
      f.assert(p.is_defined(value));
      if (this.root() === null) {
        this.root(this.NodeType().of(key, value));
      } else if (node = this.find(key)) {
        node.values().push(value);
      } else {
        this.add_descendant(this.root(), this.NodeType().of(key, value));
      }
      this.size(this.size() + 1);
      return this;
    };

    Tree.prototype.contains_key = function(key) {
      f.assert(p.is_defined(key));
      return null !== this.find(key);
    };

    Tree.prototype.find = function(key) {
      var comp, node;
      f.assert(p.is_defined(key));
      node = this.root();
      while (node) {
        comp = this.comparator()(key, node.key());
        if (comp > 0) {
          node = node.greater_child();
        } else if (comp < 0) {
          node = node.lesser_child();
        } else {
          break;
        }
      }
      return node;
    };

    Tree.prototype.find_nearest = function(key) {
      var comp, node;
      f.assert(p.is_defined(key));
      node = this.root();
      while (node) {
        comp = this.comparator()(key, node.key());
        if (comp > 0) {
          if (node.greater_child() === null) {
            break;
          }
          node = node.greater_child();
        } else if (comp < 0) {
          if (node.lesser_child() === null) {
            break;
          }
          node = node.lesser_child();
        } else {
          break;
        }
      }
      return node;
    };

    Tree.prototype.find_nearest_gte = function(key) {
      var node;
      f.assert(p.is_defined(key));
      node = this.find_nearest(key);
      while (node && this.comparator()(node.key(), key) < 0) {
        node = node.greater_neighbor();
      }
      return node;
    };

    Tree.prototype.find_nearest_lte = function(key) {
      var node;
      f.assert(p.is_defined(key));
      node = this.find_nearest(key);
      while (node && this.comparator()(node.key(), key) > 0) {
        node = node.lesser_neighbor();
      }
      return node;
    };

    Tree.prototype.remove = function(key, value) {
      var candidate, index, node, _i, _len, _ref;
      f.assert(p.is_defined(key));
      if (node = this.find(key)) {
        if (p.is_defined(value)) {
          _ref = node.values();
          for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
            candidate = _ref[index];
            if (candidate === value) {
              node.values().splice(index, 1);
              if (node.values().length === 0) {
                this.remove_node(node);
              }
              this.size(this.size() - 1);
              return true;
            }
          }
          return false;
        } else {
          this.size(this.size() - node.values().length);
          this.remove_node(node);
          return true;
        }
      } else {
        return false;
      }
    };

    Tree.prototype.preorder = function(fn, node) {
      if (node == null) {
        node = this.root();
      }
      if (node) {
        fn(node);
        if (node.lesser_child()) {
          this.preorder(fn, node.lesser_child());
        }
        if (node.greater_child()) {
          this.preorder(fn, node.greater_child());
        }
      }
      return this;
    };

    Tree.prototype.inorder = function(fn, node) {
      if (node == null) {
        node = this.root();
      }
      if (node) {
        if (node.lesser_child()) {
          this.inorder(fn, node.lesser_child());
        }
        fn(node);
        if (node.greater_child()) {
          this.inorder(fn, node.greater_child());
        }
      }
      return this;
    };

    Tree.prototype.postorder = function(fn, node) {
      if (node == null) {
        node = this.root();
      }
      if (node) {
        if (node.lesser_child()) {
          this.postorder(fn, node.lesser_child());
        }
        if (node.greater_child()) {
          this.postorder(fn, node.greater_child());
        }
        fn(node);
      }
      return this;
    };

    Tree.prototype.range = function(lower, upper) {
      var node;
      f.assert(this.comparator()(lower, upper) <= 0, "Expected lower:" + (f.to_string(lower)) + " <= upper:" + (f.to_string(upper)));
      node = this.find_nearest_gte(lower);
      return RangeIterator.of(node, upper, this.comparator());
    };

    Tree.prototype.neighbors = function(key, n_lesser, n_greater) {
      var comp, greatest, least, lower_node, n, node, upper_key;
      f.assert(p.is_defined(key));
      f.assert(p.is_non_negative_number(n_lesser));
      f.assert(p.is_non_negative_number(n_greater));
      if (node = this.find_nearest(key)) {
        comp = this.comparator()(node.key(), key);
        if ((least = comp < 0 ? node : node.lesser_neighbor())) {
          n = 1;
          while (n < n_lesser) {
            if (!least.lesser_neighbor()) {
              break;
            }
            least = least.lesser_neighbor();
            n += 1;
          }
        }
        if ((greatest = comp > 0 ? node : node.greater_neighbor())) {
          n = 1;
          while (n < n_greater) {
            if (!greatest.greater_neighbor()) {
              break;
            }
            greatest = greatest.greater_neighbor();
            n += 1;
          }
        }
        lower_node = least || node;
        upper_key = (greatest != null ? greatest.key() : void 0) || node.key();
        return RangeIterator.of(lower_node, upper_key, this.comparator());
      } else {
        return RangeIterator.empty();
      }
    };

    Tree.prototype.nearest_neighbors = function(key, k, key_distance) {
      var comp, curr, heap, node, node_distance, upper_key;
      f.assert(p.is_defined(key));
      f.assert(p.is_non_negative_number(k));
      f.assert(p.is_function(key_distance) && key_distance.length === 2);
      node_distance = function(a, b) {
        return key_distance(a.key(), key) - key_distance(b.key(), key);
      };
      heap = new MaxHeap(node_distance);
      if (k > 0 && (node = this.find_nearest(key))) {
        comp = this.comparator()(node.key(), key);
        if (comp === 0) {
          heap.push(node);
        }
        curr = comp < 0 ? node : node.lesser_neighbor();
        while (curr && heap.length < k) {
          heap.push(curr);
          curr = curr.lesser_neighbor();
        }
        curr = comp > 0 ? node : node.greater_neighbor();
        while (curr && heap.length < k) {
          heap.push(curr);
          curr = curr.greater_neighbor();
        }
        while (curr && key_distance(curr.key(), key) < key_distance(heap.peek().key(), key)) {
          heap.pop();
          heap.push(curr);
          curr = curr.greater_neighbor();
        }
        node = heap.pop();
        upper_key = node.key();
        while (curr = heap.pop()) {
          if (this.comparator()(curr.key(), node.key()) < 0) {
            node = curr;
          }
          if (this.comparator()(curr.key(), upper_key) > 0) {
            upper_key = curr.key();
          }
        }
        return RangeIterator.of(node, upper_key, this.comparator());
      } else {
        return RangeIterator.empty();
      }
    };

    return Tree;

  })(Entity);

  Entity.def_abstract_methods(Tree, {
    add_descendant: {
      arity: 2
    },
    remove_node: {
      arity: 1
    }
  });

  Entity.def_properties(Tree, {
    comparator: {
      is_valid: p.disjoin(p.conjoin(p.is_function, p.has_arity(2)), p.is_undefined)
    },
    size: {
      initial_value: 0,
      is_valid: p.is_non_negative_number
    },
    NodeType: {
      is_valid: p.disjoin(p.is_type(Node), p.is_undefined)
    },
    root: {
      initial_value: null,
      is_valid: p.disjoin(p.is_null, p.conjoin(p.is_instance(Node), Tree.prototype.is_node_type))
    }
  });

  global.vst || (global.vst = {});

  global.vst.Tree = Tree;

}).call(this);
