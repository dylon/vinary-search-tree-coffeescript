// Generated by CoffeeScript 1.7.1
(function() {
  var MaxHeap, f, global, p;

  if (typeof exports !== 'undefined') {
    global = exports;
    p = require('./predicates').vst.predicates;
    f = require('./functions').vst.functions;
  } else if (typeof window !== 'undefined') {
    global = window;
    p = window.vst.predicates;
    f = window.vst.functions;
  } else {
    global = this;
    p = this.vst.predicates;
    f = this.vst.functions;
  }

  MaxHeap = (function() {
    MaxHeap.prototype._parent = function(i) {
      if (i > 0) {
        return ((i + 1) >> 1) - 1;
      } else {
        return 0;
      }
    };

    MaxHeap.prototype._left_child = function(i) {
      return (i << 1) + 1;
    };

    MaxHeap.prototype._right_child = function(i) {
      return (i << 1) + 2;
    };

    MaxHeap.prototype._heapify = function(i) {
      var heap, l, largest, r, tmp;
      l = this._left_child(i);
      r = this._right_child(i);
      heap = this.heap;
      if (l < this.length && this.f(heap[l], heap[i]) > 0) {
        largest = l;
      } else {
        largest = i;
      }
      if (r < this.length && this.f(heap[r], heap[largest]) > 0) {
        largest = r;
      }
      if (largest !== i) {
        tmp = heap[i];
        heap[i] = heap[largest];
        heap[largest] = tmp;
        this._heapify(largest);
      }
      return null;
    };

    MaxHeap.prototype._build = function() {
      var i;
      i = this.length >> 1;
      while (i >= 0) {
        this._heapify(i);
        i -= 1;
      }
      return null;
    };

    MaxHeap.prototype.increase_key = function(i, key) {
      var heap, parent, tmp;
      f = this.f;
      heap = this.heap;
      if (f(key, heap[i]) < 0) {
        throw new Error("Expected " + key + " to be at least heap[" + i + "] = " + heap[i]);
      }
      heap[i] = key;
      parent = this._parent;
      p = parent(i);
      while (i && f(heap[p], heap[i]) < 0) {
        tmp = heap[i];
        heap[i] = heap[p];
        heap[p] = tmp;
        i = p;
        p = parent(i);
      }
      return null;
    };

    MaxHeap.prototype.sort = function() {
      var heap, i, tmp;
      this._build();
      i = this.length - 1;
      heap = this.heap;
      while (i >= 0) {
        tmp = heap[0];
        heap[0] = heap[i];
        heap[i] = tmp;
        this.length -= 1;
        this._heapify(0);
        i -= 1;
      }
      return null;
    };

    MaxHeap.prototype.peek = function() {
      if (this.length) {
        return this.heap[0];
      } else {
        return null;
      }
    };

    MaxHeap.prototype.pop = function() {
      var heap, max;
      if (this.length) {
        heap = this.heap;
        max = heap[0];
        heap[0] = heap[this.length - 1];
        this.length -= 1;
        this._heapify(0);
        return max;
      } else {
        return null;
      }
    };

    MaxHeap.prototype.push = function(key) {
      var heap, i, parent;
      i = this.length;
      this.length += 1;
      parent = this._parent;
      p = parent(i);
      heap = this.heap;
      f = this.f;
      while (i > 0 && f(heap[p], key) < 0) {
        heap[i] = heap[p];
        i = p;
        p = parent(i);
      }
      heap[i] = key;
      return null;
    };

    function MaxHeap(f, heap, length) {
      this.f = f;
      this.heap = heap != null ? heap : [];
      this.length = length != null ? length : heap.length;
      f.assert(p.is_array(heap));
      f.assert(p.is_bounded(0, heap.length)(length));
      f.assert(p.is_function(f));
      this._build();
    }

    return MaxHeap;

  })();

  global.vst || (global.vst = {});

  global.vst.MaxHeap = MaxHeap;

}).call(this);
