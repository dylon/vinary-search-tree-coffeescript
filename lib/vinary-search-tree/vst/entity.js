// Generated by CoffeeScript 1.7.1
(function() {
  var Entity, f, global, is_entity, is_valid_assertion, p, safe_get, safe_value, validate,
    __hasProp = {}.hasOwnProperty;

  if (typeof exports !== 'undefined') {
    global = exports;
    p = require('./predicates').vst.predicates;
    f = require('./functions').vst.functions;
  } else if (typeof window !== 'undefined') {
    global = window;
    p = window.vst.predicates;
    f = window.vst.functions;
  } else {
    global = this;
    p = this.vst.predicates;
    f = this.vst.functions;
  }

  is_valid_assertion = function(is_valid, property) {
    return function(self, value) {
      if (!is_valid.call(self, value)) {
        throw new Error("" + (f.to_string(value)) + " is invalid for " + self.constructor.name + "." + property);
      }
      return value;
    };
  };

  safe_get = function(self, attr) {
    if (p.is_function(self[attr])) {
      return self[attr]();
    } else {
      return self[attr];
    }
  };

  safe_value = function(self, value) {
    if (p.is_function(value)) {
      return value.call(self);
    } else {
      return value;
    }
  };

  validate = function(value) {
    var element, k, v, _i, _len, _results, _results1;
    if (value instanceof Entity) {
      return value.validate();
    } else if (p.is_array(value)) {
      _results = [];
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        element = value[_i];
        _results.push(validate(element));
      }
      return _results;
    } else if (p.is_object(value)) {
      _results1 = [];
      for (k in value) {
        if (!__hasProp.call(value, k)) continue;
        v = value[k];
        _results1.push(validate(v));
      }
      return _results1;
    } else {
      return true;
    }
  };

  Entity = (function() {
    Entity.def_property = function(ctor, property, _arg) {
      var assert_is_valid, field, get, init, initial_value, is_valid, set, stringify, _ref;
      initial_value = _arg.initial_value, get = _arg.get, init = _arg.init, is_valid = _arg.is_valid, set = _arg.set, stringify = _arg.stringify;
      if (!p.is_function(ctor)) {
        throw new Error("" + property + ".ctor=" + (f.to_string(ctor)) + " must be a function");
      }
      if (!p.is_string(property)) {
        throw new Error("property=" + (f.to_string(property)) + " must be a string");
      }
      if (!(p.is_function(is_valid) && is_valid.length <= 1)) {
        throw new Error("" + property + ".is_valid=" + (f.to_string(is_valid)) + " must be a function of arity <= 1");
      }
      if (!(p.is_undefined(get) || p.is_function(get) && get.length <= 1)) {
        throw new Error("" + property + ".get=" + (f.to_string(get)) + " must not be specified or must be a function of arity <= 1");
      }
      if (!(p.is_undefined(set) || p.is_function(set) && (1 <= (_ref = set.length) && _ref <= 2))) {
        throw new Error("" + property + ".set=" + (f.to_string(set)) + " must not be specified or must be a function of arity of 1 or 2");
      }
      if (!(p.is_undefined(init) || p.is_function(init) && init.length <= 1)) {
        throw new Error("" + property + ".init=" + (f.to_string(init)) + " must not be specified or must be a function of arity <= 1");
      }
      if (!(p.is_undefined(initial_value) || is_valid(initial_value))) {
        throw new Error("" + (f.to_string(initial_value)) + " is invalid for " + property);
      }
      if (!(p.is_undefined(stringify) || p.is_boolean(stringify))) {
        throw new Error("Expected " + property + ".stringify=" + (f.to_string(stringify)) + " to be a boolean");
      }
      get || (get = function(field) {
        return this[field];
      });
      set || (set = function(field, value) {
        return this[field] = value;
      });
      if (set.length === 1) {
        set = (function(set) {
          return function(field, value) {
            return set(value);
          };
        })(set);
      }
      field = '__' + property;
      assert_is_valid = is_valid_assertion(is_valid, property);
      if (!p.is_undefined(initial_value)) {
        ctor.prototype[field] = initial_value;
      }
      ctor.__INITIALIZERS__ || (ctor.__INITIALIZERS__ = {});
      ctor.prototype[property] = function(value) {
        var _base;
        if (p.is_undefined(value)) {
          this.__GET_CALLSTACK_SIZE__ || (this.__GET_CALLSTACK_SIZE__ = {});
          (_base = this.__GET_CALLSTACK_SIZE__)[property] || (_base[property] = 0);
          this.__GET_CALLSTACK_SIZE__[property] += 1;
          if (this.__GET_CALLSTACK_SIZE__[property] > 1) {
            return this[field];
          }
          value = assert_is_valid(this, get.call(this, field));
          delete this.__GET_CALLSTACK_SIZE__[property];
          return value;
        } else {
          assert_is_valid(this, value);
          set.call(this, field, value);
          return this;
        }
      };
      if (stringify === false) {
        ctor.prototype[property].__STRINGIFY__ = false;
      }
      ctor.prototype[property].is_valid = is_valid;
      ctor.__PROPERTIES__ || (ctor.__PROPERTIES__ = []);
      ctor.__PROPERTIES__.push(property);
      ctor.properties || (ctor.properties = function() {
        var properties;
        return properties = p.is_function(ctor.__super__.properties) ? ctor.__super__.properties().concat(ctor.__PROPERTIES__) : ctor.__PROPERTIES__;
      });
      ctor.__VALIDATORS__ || (ctor.__VALIDATORS__ = {});
      ctor.__VALIDATORS__[property] = is_valid;
      if (init) {
        ctor.__INITIALIZERS__[field] = init;
      }
      return true;
    };

    Entity.def_properties = function(ctor, properties) {
      var attrs, property, _results;
      f.assert(p.is_function(ctor) && is_entity(ctor.prototype), "Expected " + ctor.name + "=" + (f.to_string(ctor)) + " to inherit from Entity");
      f.assert(p.is_object(properties));
      _results = [];
      for (property in properties) {
        if (!__hasProp.call(properties, property)) continue;
        attrs = properties[property];
        _results.push(this.def_property(ctor, property, attrs));
      }
      return _results;
    };

    Entity.def_abstract_method = function(ctor, abstract_method, _arg) {
      var arity;
      arity = _arg.arity;
      f.assert(p.is_undefined(arity) || p.is_non_negative_number(arity), "Expected arity=" + (f.to_string(arity)) + " to be a non-negative number");
      ctor.__ABSTRACT_METHODS__ || (ctor.__ABSTRACT_METHODS__ = {});
      ctor.__ABSTRACT_METHODS__[abstract_method] = {};
      if (p.is_defined(arity)) {
        return ctor.__ABSTRACT_METHODS__[abstract_method].arity = arity;
      }
    };

    Entity.def_abstract_methods = function(ctor, abstract_methods) {
      var abstract_method, attrs, _results;
      f.assert(p.is_function(ctor));
      f.assert(p.is_object(abstract_methods));
      _results = [];
      for (abstract_method in abstract_methods) {
        if (!__hasProp.call(abstract_methods, abstract_method)) continue;
        attrs = abstract_methods[abstract_method];
        _results.push(this.def_abstract_method(ctor, abstract_method, attrs));
      }
      return _results;
    };

    Entity.find_property = function(ctor, property) {
      f.assert(is_entity(ctor.prototype));
      f.assert(p.is_string(property));
      if (p.is_function(ctor.prototype[property])) {
        return ctor.prototype[property];
      } else if (ctor.__super__ && is_entity(ctor.__super__.prototype)) {
        return this.find_property(ctor.__super__, property);
      } else {
        return null;
      }
    };

    Entity.def_toString = function(ctor, ctor_name) {
      var properties, property, property_name, _i, _len, _ref;
      f.assert(p.is_function(ctor) && is_entity(ctor.prototype));
      f.assert(p.is_undefined(ctor_name) || p.is_string(ctor_name));
      ctor_name || (ctor_name = ctor.name);
      properties = [];
      _ref = ctor.properties();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property_name = _ref[_i];
        if (property = this.find_property(ctor, property_name)) {
          if (property.__STRINGIFY__ !== false) {
            properties.push(property_name);
          }
        }
      }
      ctor.prototype.toString = function() {
        var value, values, _j, _len1;
        values = [];
        for (_j = 0, _len1 = properties.length; _j < _len1; _j++) {
          property = properties[_j];
          value = safe_get(this, property);
          values.push(property + ': ' + f.to_string(value));
        }
        return "" + ctor_name + " {" + (values.join(', ')) + "}";
      };
      return true;
    };

    function Entity(subtypes) {
      var abstract_method, abstract_methods, arity, attrs, field, init, subtype, type, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (!p.is_array(subtypes)) {
        throw new Error("Expected " + (f.to_string(subtypes)) + " to be an array");
      }
      abstract_methods = {};
      for (_i = 0, _len = subtypes.length; _i < _len; _i++) {
        subtype = subtypes[_i];
        if (subtype !== undefined) {
          if (!(p.is_function(subtype) && subtype.prototype instanceof Entity && this instanceof subtype)) {
            throw new Error("" + subtype.name + " must be of type Entity");
          }
          if (subtype.__ABSTRACT_METHODS__) {
            _ref = subtype.__ABSTRACT_METHODS__;
            for (abstract_method in _ref) {
              if (!__hasProp.call(_ref, abstract_method)) continue;
              attrs = _ref[abstract_method];
              abstract_method[abstract_method] = {
                type: subtype,
                attrs: attrs
              };
            }
          }
          _ref1 = subtype.__INITIALIZERS__;
          for (field in _ref1) {
            if (!__hasProp.call(_ref1, field)) continue;
            init = _ref1[field];
            this[field] = init.call(this, field);
          }
        }
      }
      type = subtypes[subtypes.length - 1];
      this.__TYPE__ = type;
      for (abstract_method in abstract_methods) {
        if (!__hasProp.call(abstract_methods, abstract_method)) continue;
        _ref2 = abstract_methods[abstract_method], type = _ref2.type, (_ref3 = _ref2.attrs, arity = _ref3.arity);
        f.assert(p.is_method(this[abstract_method]), "Expected " + (to_string(this)) + " to implemented " + type.name + "::" + abstract_method);
        if (p.is_defined(arity)) {
          f.assert(this[abstract_method].length >= arity, "Expected " + (to_string(f)) + " to have an arity of at least " + arity);
        }
      }
    }

    Entity.prototype.validate = function() {
      var is_valid, property, value, _ref;
      _ref = this.__TYPE__.__VALIDATORS__;
      for (property in _ref) {
        if (!__hasProp.call(_ref, property)) continue;
        is_valid = _ref[property];
        value = this[property]();
        if (!is_valid.call(this, value)) {
          throw new Error("" + (f.to_string(value)) + " is invalid for " + property + " according to " + is_valid + " for " + (f.to_string(this)));
        }
        validate(value);
      }
      return this;
    };

    Entity.prototype.equals = function(self, other) {
      var property, _i, _len, _ref;
      if (p.is_undefined(other)) {
        other = self;
        self = this;
      }
      if (is_entity(self)) {
        if (is_entity(other)) {
          _ref = self.constructor.properties();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            property = _ref[_i];
            if (!this.equals(self[property](), other[property]())) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      } else {
        return self === other;
      }
    };

    return Entity;

  })();

  is_entity = p.is_instance(Entity);

  global.vst || (global.vst = {});

  global.vst.Entity = Entity;

}).call(this);
