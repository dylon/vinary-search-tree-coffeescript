// Generated by CoffeeScript 1.7.1
(function() {
  var AvlNode, AvlTree, Entity, Tree, f, global, p,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof exports !== 'undefined') {
    global = exports;
    Entity = require('./entity').vst.Entity;
    AvlNode = require('./avl_node').vst.AvlNode;
    Tree = require('./tree').vst.Tree;
    p = require('./predicates').vst.predicates;
    f = require('./functions').vst.functions;
  } else if (typeof window !== 'undefined') {
    global = window;
    Entity = window.vst.Entity;
    AvlNode = window.vst.AvlNode;
    Tree = window.vst.Tree;
    p = window.vst.predicates;
    f = window.vst.functions;
  } else {
    global = this;
    Entity = this.vst.Entity;
    AvlNode = this.vst.AvlNode;
    Tree = this.vst.Tree;
    p = this.vst.predicates;
    f = this.vst.functions;
  }

  AvlTree = (function(_super) {
    __extends(AvlTree, _super);

    AvlTree.of()(function() {
      return new AvlTree();
    });

    function AvlTree(subtypes) {
      if (subtypes == null) {
        subtypes = [];
      }
      if (!(this instanceof AvlTree)) {
        return new AvlTree(subtypes);
      }
      subtypes.push(AvlTree);
      AvlTree.__super__.constructor.call(this, subtypes);
    }

    AvlTree.prototype.greater_greater_case = function(a) {
      var b, c;
      this.assert_is_node_type(a);
      f = a.parent();
      b = a.greater_child();
      c = b.greater_child();
      a.greater_child(b.lesser_child());
      if (a.greater_child()) {
        a.greater_child().parent(a);
      }
      b.lesser_child(a);
      a.parent(b);
      if (f) {
        if (f.greater_child() === a) {
          f.greater_child(b);
        } else {
          f.lesser_child(b);
        }
        b.parent(f);
      } else {
        b.parent(null);
        this.root(b);
      }
      this.recompute_heights(a);
      this.recompute_heights(b.parent());
      return this;
    };

    AvlTree.prototype.greater_lesser_case = function(a) {
      var b, c;
      this.assert_is_node_type(a);
      f = a.parent();
      b = a.greater_child();
      c = b.lesser_child();
      b.lesser_child(c.greater_child());
      if (b.lesser_child()) {
        b.lesser_child().parent(b);
      }
      a.greater_child(c.lesser_child());
      if (a.greater_child()) {
        a.greater_child().parent(a);
      }
      c.greater_child(b);
      b.parent(c);
      c.lesser_child(a);
      a.parent(c);
      if (f) {
        if (f.greater_child() === a) {
          f.greater_child(c);
        } else {
          f.lesser_child(c);
        }
        c.parent(f);
      } else {
        c.parent(null);
        this.root(c);
      }
      this.recompute_heights(a);
      this.recompute_heights(b);
      return this;
    };

    AvlTree.prototype.lesser_lesser_case = function(a) {
      var b, c;
      this.assert_is_node_type(a);
      f = a.parent();
      b = a.lesser_child();
      c = b.lesser_child();
      a.lesser_child(b.greater_child());
      if (a.lesser_child()) {
        a.lesser_child().parent(a);
      }
      b.greater_child(a);
      a.parent(b);
      if (f) {
        if (f.greater_child() === a) {
          f.greater_child(b);
        } else {
          f.lesser_child(b);
        }
        b.parent(f);
      } else {
        b.parent(null);
        this.root(b);
      }
      this.recompute_heights(a);
      this.recompute_heights(b.parent());
      return this;
    };

    AvlTree.prototype.lesser_greater_case = function(a) {
      var b, c;
      this.assert_is_node_type(a);
      f = a.parent();
      b = a.lesser_child();
      c = b.greater_child();
      a.lesser_child(c.greater_child());
      if (a.lesser_child()) {
        a.lesser_child().parent(a);
      }
      b.greater_child(c.lesser_child());
      if (b.greater_child()) {
        b.greater_child().parent(b);
      }
      c.lesser_child(b);
      b.parent(c);
      c.greater_child(a);
      a.parent(c);
      if (f) {
        if (f.greater_child() === a) {
          f.greater_child(c);
        } else {
          f.lesser_child(c);
        }
        c.parent(f);
      } else {
        c.parent(null);
        this.root(c);
      }
      this.recompute_heights(a);
      this.recompute_heights(b);
      return this;
    };

    AvlTree.prototype.rebalance = function(a) {
      var balance;
      this.assert_is_node_type(a);
      balance = a.balance();
      if (balance <= -2) {
        if (a.greater_child().balance() <= 0) {
          this.greater_greater_case(a);
        } else {
          this.greater_lesser_case(a);
        }
      } else if (balance >= 2) {
        if (a.lesser_child().balance() >= 0) {
          this.lesser_lesser_case(a);
        } else {
          this.lesser_greater_case(a);
        }
      }
      return this;
    };

    AvlTree.prototype.recompute_heights = function(node) {
      var changed, height;
      this.assert_is_node_type(node);
      changed = true;
      while (node && changed) {
        height = node.height();
        node.height(node.greater_child() || node.lesser_greater_case() ? 1 + node.max_child_height() : 0);
        changed = node.height !== height;
        node = node.parent();
      }
      return this;
    };

    AvlTree.prototype.add_descendant = function(ancestor, descendant) {
      var child, comp;
      this.assert_is_node_type(ancestor);
      this.assert_is_node_type(descendant);
      comp = this.comparator()(descendant.key(), ancestor.key());
      child = null;
      if (comp < 0) {
        child = this.add_lesser_child(ancestor, descendant);
      } else if (comp > 0) {
        child = this.add_greater_child(ancestor, descendant);
      } else {
        this.add_equivalent_child(descendant);
      }
      if (child) {
        this.rebalance(child);
      }
      return this;
    };

    AvlTree.prototype.add_lesser_child = function(parent, child) {
      var candidate, node;
      this.assert_is_node_type(parent);
      this.assert_is_node_type(child);
      child.greater_neighbor(parent);
      candidate = null;
      if (parent.lesser_child()) {
        this.add_descendant(parent.lesser_child(), child);
      } else {
        parent.lesser_child(child);
        child.parent(parent);
        if (parent.lesser_neighbor()) {
          parent.lesser_neighbor().greater_neighbor(child);
        }
        parent.lesser_neighbor(child);
        if (parent.height() === 0) {
          node = parent;
          while (node) {
            node.height(1 + node.max_child_height());
            if (!node.is_balanced()) {
              candidate = node;
              break;
            }
            node = node.parent();
          }
        }
      }
      return candidate;
    };

    AvlTree.prototype.add_greater_child = function(parent, child) {
      var candidate, node;
      this.assert_is_node_type(parent);
      this.assert_is_node_type(child);
      child.lesser_neighbor(parent);
      candidate = null;
      if (parent.greater_child()) {
        this.add_descendant(parent.greater_child(), child);
      } else {
        parent.greater_child(child);
        child.parent(parent);
        if (parent.greater_neighbor()) {
          parent.greater_neighbor().lesser_neighbor(child);
        }
        parent.greater_neighbor(child);
        if (parent.height() === 0) {
          node = parent;
          while (node) {
            node.height(1 + node.max_child_height());
            if (!node.is_balanced()) {
              candidate = node;
              break;
            }
            node = node.parent();
          }
        }
      }
      return candidate;
    };

    AvlTree.prototype.add_equivalent_child = function(parent, child) {
      this.assert_is_node_type(parent);
      this.assert_is_node_type(child);
      parent.values(parent.values().concat(child.values()));
      child.lesser_neighbor(null);
      child.greater_neighbor(null);
      child.lesser_child(null);
      child.greater_child(null);
      child.values().length = 0;
      child.parent(null);
      return null;
    };

    AvlTree.prototype.remove_node = function(node) {
      this.assert_is_node_type(node);
      node.values().length = 0;
      if (node.lesser_neighbor()) {
        node.lesser_neighbor(node.greater_neighbor());
      }
      if (node.greater_neighbor()) {
        node.greater_neighbor(node.lesser_neighbor());
      }
      if (node.is_leaf()) {
        this.remove_leaf(node);
      } else if (node.is_branch()) {
        this.remove_branch(node);
      } else {
        this.swap_and_remove(node);
      }
      return this;
    };

    AvlTree.prototype.remove_leaf = function(node) {
      var parent;
      this.assert_is_node_type(node);
      if (parent = node.parent()) {
        if (parent.lesser_child() === node) {
          parent.lesser_child(null);
        } else {
          parent.greater_child(null);
        }
        this.recompute_heights(parent);
        while (node = node.parent()) {
          if (!node.is_balanced()) {
            this.rebalance(node);
          }
        }
      } else {
        this.root(null);
      }
      return null;
    };

    AvlTree.prototype.remove_branch = function(node) {
      var parent;
      this.assert_is_node_type(node);
      if (parent = node.parent()) {
        if (parent.lesser_child()) {
          parent.lesser_child(node.greater_child() || node.lesser_child());
        } else {
          parent.greater_child(node.greater_child() || node.lesser_child());
        }
        if (node.greater_child()) {
          node.greater_child().parent(parent);
        } else {
          node.lesser_child().parent(parent);
        }
        this.recompute_heights(parent);
        while (node = node.parent()) {
          if (!node.is_balanced()) {
            this.rebalance(node);
          }
        }
      }
      return null;
    };

    AvlTree.prototype.swap_and_remove = function(node) {
      var successor;
      this.assert_is_node_type(node);
      successor = this.least(node.greater_child());
      this.swap_nodes(node, successor);
      if (node.height() === 0) {
        this.remove_leaf(node);
      } else {
        this.remove_branch(node);
      }
      return null;
    };

    AvlTree.prototype.swap_nodes = function(node_1, node_2) {
      var greater_child_1, greater_child_2, height, lesser_child_1, lesser_child_2, parent_1, parent_2;
      this.assert_is_node_type(node_1);
      this.assert_is_node_type(node_2);
      parent_1 = node_1.parent();
      lesser_child_1 = node_1.lesser_child();
      greater_child_1 = node_1.greater_child();
      parent_2 = node_2.parent();
      lesser_child_2 = node_2.lesser_child();
      greater_child_2 = node_2.greater_child();
      height = node_1.height();
      node_1.height(node_2.height());
      node_2.height(height);
      if (parent_1) {
        if (parent_1.lesser_child() === node_1) {
          parent.lesser_child(node_2);
        } else {
          parent.greater_child(node_2);
        }
        node_2.parent(parent);
      } else {
        node_2.parent(null);
        this.root(node_2);
      }
      node_2.lesser_child(lesser_child_1);
      lesser_child_1.parent(node_2);
      node_1.lesser_child(lesser_child_2);
      lesser_child_2.parent(node_1);
      if (greater_child_2) {
        greater_child_2.parent(node_1);
      } else if (parent_2 !== node_1) {
        node_2.greater_child(greater_child_1);
        greater_child_1.parent(node_2);
        parent_2.lesser_child(node_1);
        node_1.parent(parent_2);
      } else {
        node_2.greater_child(node_1);
        node_1.parent(node_2);
      }
      return null;
    };

    return AvlTree;

  })(Tree);

  Entity.def_toString(AvlTree);

  global.vst || (global.vst = {});

  global.vst.AvlTree = AvlTree;

}).call(this);
